<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    const o = {
      name: 1,
      sex: 2,
      method: function () {
        return "hello!"
      }
    }
    console.log(o);
    const birth = 2001
    const Person = {
      name: '张三',
      // 等同于birth:birth
      birth,
      hello () { console.log('mynameis', this.name); }
    }


    // 对象属性的可枚举性和遍历

    // 描述对象的enumerable属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性。

    // 目前，有四个操作会忽略enumerable为false的属性。

    // for...in循环：只遍历对象自身的和继承的可枚举的属性。
    // Object.keys()：返回对象自身的所有可枚举的属性的键名。
    // JSON.stringify()：只串行化对象自身的可枚举的属性。
    // Object.assign()： 忽略enumerable为false的属性，只拷贝
    // ES6 规定，所有 Class 的原型的方法都是不可枚举的。

    // 5种属性遍历方法

    // 1.for...in方法,for...in循环遍历对象自身的和继承的可枚举属性
    for (ele in Person) {
      console.log(ele);
    }
    // Object.keys(obj)
    （2）Object.keys(obj)

    // Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。

    // （3）Object.getOwnPropertyNames(obj)

    // Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。

    // （4）Object.getOwnPropertySymbols(obj)

    // Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。

    // （5）Reflect.ownKeys(obj)

    // Reflect.ownKeys返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。



    // this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。

    const proto = {
      foo: 'hello'
    };

    const obj = {
      foo: 'world',
      find () {
        return super.foo;
      }
    };

    Object.setPrototypeOf(obj, proto);
    obj.find() // "hello"
    // super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。
  </script>
</body>

</html>